# -*- coding: utf-8 -*-
"""s18579_gr12c_PRO7.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1r-EjSYwGAjdfdRY32ud_Ex-v-5zC6TV-

#Pobranie danych

https://docs.bitbay.net/reference#wykres
"""

def Exy(x, y):
  i = 0
  sum = 0
  while i < len(x):
    sum += x[i]*y[i]
    i+=1
  return sum

def Ex2y(x, y):
  i = 0
  sum = 0
  while i < len(x):
    sum += (x[i]**2)*y[i]
    i+=1
  return sum

def Ey(y):
  i = 0
  sum = 0
  while i < len(y):
    sum += y[i]
    i+=1
  return sum

def Ex4(x):
  i = 0
  sum = 0
  while i < len(x):
    sum += x[i]**4
    i+=1
  return sum

def Ex3(x):
  i = 0
  sum = 0
  while i < len(x):
    sum += x[i]**3
    i+=1
  return sum

def Ex2(x):
  i = 0
  sum = 0
  while i < len(x):
    sum += x[i]**2
    i+=1
  return sum

def Ex(x):
  i = 0
  sum = 0
  while i < len(x):
    sum += x[i]
    i+=1
  return sum

def regVector(w2,w1,w0, x):
  i = 0
  y = []
  while i < len(x):
    y.append((w2*(x[i]**2))+(w1*x[i])+w0)
    i+=1
  return y

def checkDiff2(x, y, w0, w1, w2):
  i = 0
  sum = 0
  while i < len(x):
    sum += ((y[i] - ((w0*(x[i]**2))+(w1*x[i])+w2))**2)
    i+=1
  return sum

import requests
import matplotlib.pyplot as plt

url = "https://api.bitbay.net/rest/trading/stats"

headers = {'content-type': 'application/json'}

response = requests.request("GET", url, headers=headers)

for j in response.json()['items']:
  print('kod rynku: {}'.format(j))

def dataSet(res):
  yall = []
  while i < len(50):
    j = response.json()['items'][i]
    ysmall = []
    ysmall.append(float(j[1]['o']))
    ysmall.append(float(j[1]['c']))
    yall.append(ysmall)
    i+=1
  return yall

url = "https://api.bitbay.net/rest/trading/candle/history/LTC-PLN/900?from=1540210129000&to=1543410329000"

response = requests.request("GET", url)
y = []
X = []
i = 0
while i < len(response.json()['items']):
  j = response.json()['items'][i]
  y.append((float(j[1]['o'])+float(j[1]['c']))/2.)
  X.append(i)
  i+=1

print(len(response.json()['items']))
plt.plot(X,y)
plt.show()

"""#1. Dla notowań giełdowych kryptowaluty zaproponuj i zrealizuj podział tych danych na dane treningowe i dane testowe,"""

from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3,random_state=1)
plt.plot(X_test, y_test, 'r*')
plt.plot(X_train, y_train, 'b*')
plt.show()

"""#2. Zaproponuj liniowy model autoregresyjny (model AR) biorący pod uwagę kilka wcześniejszych notowań (nie więcej niż 50). Określ parametry modelu stosując metodę najmniejszych kwadratów. Zweryfikuj poprawność modelu,"""

import matplotlib.pyplot as plt
import numpy as np
from sklearn.model_selection import train_test_split
X_50 = []
y_50 = []
for i in range(50):
  X_50.append(X_train[i])
  y_50.append(y_train[i])
matrix = np.array([
                   [Ex4(X_50), Ex3(X_50), Ex2(X_50)],
                   [Ex3(X_50), Ex2(X_50), Ex(X_50)],
                   [Ex2(X_50), Ex(X_50), len(X_50)]
                   ])
multi = np.array([Ex2y(X_50,y_50),Exy(X_50,y_50),Ey(y_50)])
vector = np.matmul(np.linalg.inv(matrix), multi)
reg3 = regVector(vector[0],vector[1],vector[2],X)
print("Poprawność:\t"+str(checkDiff2(X,y,vector[0],vector[1],vector[2])))
#TODO: -- wyswietlic procent spadku --
plt.plot(X_50, y_50, 'r*')
plt.plot(X,reg3)
plt.show()

"""#3. Zaproponuj sieć neuronową rekurencyjną do predykcji notowań. Wytrenuj sieć (zastosuj znane ci techniki trenowania sieci jak porzucanie, skalowanie etc.). Zweryfikuj poprawność modelu,"""

from keras.models import Sequential
from keras.layers import Dense, Activation, LSTM
import numpy as np
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split

model = Sequential()
model.add(Dense(units=2000, input_shape=(1, ), activation='relu')) #'tanh' 'relu' 'sigmoid'
model.add(Dense(units=200))
model.add(Activation('relu'))
model.add(Dense(units=1))

# Compiling the RNN
model.compile(loss='mean_squared_error', optimizer='adam')


# Fitting the RNN
model.fit(X_train, y_train, epochs=200, verbose=1)
r = model.predict(X_test)
plt.plot(X_test,y_test,'b.')
plt.plot(X_test,r,'r.')
plt.show()

"""#4. Do predykcji notowań użyj dodatkowych dostępnych danych,"""



"""#5. Porównaj modele AR i rekurencyjne sieci neuronowe."""

